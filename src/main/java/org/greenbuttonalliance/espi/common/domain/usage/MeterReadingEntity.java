/*
 *
 *    Copyright (c) 2018-2025 Green Button Alliance, Inc.
 *
 *    Portions (c) 2013-2018 EnergyOS.org
 *
 *     Licensed under the Apache License, Version 2.0 (the "License");
 *     you may not use this file except in compliance with the License.
 *     You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *     Unless required by applicable law or agreed to in writing, software
 *     distributed under the License is distributed on an "AS IS" BASIS,
 *     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *     See the License for the specific language governing permissions and
 *     limitations under the License.
 *
 */

package org.greenbuttonalliance.espi.common.domain.usage;

import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.ToString;
import org.hibernate.annotations.LazyCollection;
import org.hibernate.annotations.LazyCollectionOption;

import jakarta.persistence.*;
import java.util.ArrayList;
import java.util.List;

/**
 * Pure JPA/Hibernate entity for MeterReading without JAXB concerns.
 * 
 * Represents a set of values obtained from the meter. Contains interval blocks
 * with specific reading data and associated reading type information.
 */
@Entity
@Table(name = "meter_readings", uniqueConstraints = {
    @UniqueConstraint(columnNames = {"uuid"})
})
@Data
@EqualsAndHashCode(callSuper = true)
@NoArgsConstructor
@ToString(callSuper = true, exclude = {"intervalBlocks", "usagePoint", "readingType"})
public class MeterReadingEntity extends IdentifiedObject {

    private static final long serialVersionUID = 1L;

    /**
     * Usage point that this meter reading belongs to.
     * Many meter readings can belong to one usage point.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "usage_point_id")
    private UsagePointEntity usagePoint;

    /**
     * Reading type that defines what this meter reading measures.
     * Many meter readings can share the same reading type.
     */
    @ManyToOne(cascade = CascadeType.ALL, fetch = FetchType.EAGER)
    @JoinColumn(name = "reading_type_id")
    private ReadingTypeEntity readingType;

    /**
     * Interval blocks containing the actual meter reading data.
     * One-to-many relationship with cascade and orphan removal.
     * Uses lazy loading for performance.
     */
    @OneToMany(mappedBy = "meterReading", cascade = CascadeType.ALL, orphanRemoval = true)
    @LazyCollection(LazyCollectionOption.TRUE)
    private List<IntervalBlockEntity> intervalBlocks = new ArrayList<>();

    // Note: Interval block collection accessors are generated by Lombok @Data
    // Bidirectional relationship management methods removed - handled by DataCustodian/ThirdParty applications

    // Note: Simple setUsagePoint setter is generated by Lombok @Data
    // Complex bidirectional relationship management removed - handled by DataCustodian/ThirdParty applications

    /**
     * Generates the self href for this meter reading.
     * 
     * @return self href string
     */
    public String getSelfHref() {
        if (usagePoint != null) {
            return usagePoint.getSelfHref() + "/MeterReading/" + getHashedId();
        }
        return "/espi/1_1/resource/MeterReading/" + getHashedId();
    }

    /**
     * Generates the up href for this meter reading.
     * 
     * @return up href string pointing to the usage point
     */
    public String getUpHref() {
        if (usagePoint != null) {
            return usagePoint.getSelfHref() + "/MeterReading";
        }
        return "/espi/1_1/resource/MeterReading";
    }

    /**
     * Overrides the default self href generation to use meter reading specific logic.
     * 
     * @return self href for this meter reading
     */
    @Override
    protected String generateDefaultSelfHref() {
        return getSelfHref();
    }

    /**
     * Overrides the default up href generation to use meter reading specific logic.
     * 
     * @return up href for this meter reading
     */
    @Override
    protected String generateDefaultUpHref() {
        return getUpHref();
    }

    /**
     * Merges data from another MeterReadingEntity.
     * Handles interval blocks with UUID validation and replacement logic.
     * 
     * @param other the other meter reading entity to merge from
     */
    public void merge(MeterReadingEntity other) {
        if (other != null) {
            super.merge(other);
            
            // Merge interval blocks with replacement logic
            // Note: Bidirectional relationship setup handled by applications
            if (other.intervalBlocks != null) {
                this.intervalBlocks = new ArrayList<>(other.intervalBlocks);
            }
            
            // Update reading type if provided
            if (other.readingType != null) {
                this.readingType = other.readingType;
            }
            
            // Update usage point if provided
            if (other.usagePoint != null) {
                this.usagePoint = other.usagePoint;
            }
        }
    }

    /**
     * Clears all relationships when unlinking the entity.
     * Simplified - applications handle relationship cleanup.
     */
    public void unlink() {
        clearRelatedLinks();
        
        // Simple collection clearing - applications handle bidirectional cleanup
        intervalBlocks.clear();
        
        // Clear relationships with simple field assignment
        this.readingType = null;
        this.usagePoint = null;
    }

    /**
     * Sets up the parent relationship with a usage point.
     * Used by the resource management system.
     * Note: Bidirectional relationship setup handled by applications.
     * 
     * @param resource the parent usage point resource
     */
    public void setUpResource(IdentifiedObject resource) {
        if (resource instanceof UsagePointEntity parentUsagePoint) {
            this.usagePoint = parentUsagePoint;
        }
    }
}